<html>

<head>
  <style id="breathe_4353">
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #1a2637;
    }

    .breathing-circle {
      width: 20vh;
      height: 20vh;
      background: radial-gradient(circle at 35% 35%,
          #8dcdff 0%,
          rgba(129, 212, 250, 0.9) 25%,
          rgba(100, 181, 246, 0.8) 50%,
          rgba(79, 159, 227, 0.6) 100%);
      border-radius: 50%;
      /* filter: blur(1px); */
      /* box-shadow:  */
      /*   0 0 30px rgba(100, 181, 246, 0.3), */
      /*   inset -5px -5px 20px rgba(0, 0, 0, 0.2), */
      /*   inset 5px 5px 20px rgba(255, 255, 255, 0.2); */
      animation: breathe 11s infinite;
    }

    @keyframes breathe {

      0%,
      100% {
        /* Inhale */
        transform: scale(1);
        animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }

      35% {
        /* Hold */
        transform: scale(2);
        animation-timing-function: linear;
      }

      40% {
        /* Exhale */
        transform: scale(2);
        animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }

      90% {
        /* Hold */
        transform: scale(1);
        animation-timing-function: linear;
      }
    }
  </style>
</head>

<body>
  <div class="breathing-circle"></div>
  <script>
    function playTones(tones = [{ frequency: 108, gain: 1 }], duration = 1000) {
      console.log('playing tone')
      fadeDuration = 0.2
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);

      // Create oscillators for each tone
      const oscillators = tones.map(tone => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        // Configure oscillator
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(tone.frequency, audioContext.currentTime);

        // Set gain for this tone
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(tone.gain, audioContext.currentTime + fadeDuration);
        if (duration) {
          gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + (duration / 1000));
        }

        // Connect this oscillator to its gain node, then to master gain
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        // Start the oscillator
        oscillator.start();
        if (duration) {
          oscillator.stop(audioContext.currentTime + (duration / 1000));
        }

        return { oscillator, gainNode };
      });

      const contoller = {
        stop: () => {
          console.log('stop tones')
          oscillators.forEach(({ oscillator, gainNode }) => {
            masterGain.gain.cancelScheduledValues(audioContext.currentTime);
            masterGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + fadeDuration);
            setTimeout(() => oscillator.stop(), fadeDuration * 2100);
          });
        }
      };
      return contoller
    }

    let tones;
    isPlaying = false;
    toggleTones = () => {
      if (tones && isPlaying) {
        tones.stop()
        isPlaying = false;
      } else {
      tones = playTones([
        { frequency: 108, gain: 0.5 },  // Base tone
        { frequency: 162, gain: 0.25 }, // Higher tone at half volume
        { frequency: 216, gain: 0.15 }  // Even higher tone at lower volume
      ], duration = 0);
      // setTimeout(tones.stop, 5000)
      isPlaying = true;
      }
    }

    document.body.addEventListener('click', (e) => {
      toggleTones()
    });
    // document.body.addEventListener('touchstart', (e) => {
    //   // Prevent default to avoid double-firing on some devices
    //   e.preventDefault();
    //   console.log('tap')
    //   toggleTones()      
    // });
  </script>
  <script>
    // TODO: function to take number of seconds of each stage of box breathing, calc %s, and update the animation duration with the total 
    // update keyframe offsets for breathing animation to configure box breathing
    function updateKeyframes(inhale, hold1, exhale) {
      const ss = Array.from(document.styleSheets).find(sheet => sheet.ownerNode.id === 'breathe_4353')
      ss.deleteRule(Array.from(ss.cssRules).findIndex(x => x.cssText.startsWith('@keyframes breathe')))
      ss.insertRule(` @keyframes breathe {
      0%, 100% {
        /* Inhale */
        transform: scale(1);
        animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }
      ${inhale}% {
        /* Hold */
        transform: scale(2);
        animation-timing-function: linear;
      }
      ${hold1}% {
        /* Exhale */
        transform: scale(2);
        animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }
      ${exhale}% {
        /* Hold */
        transform: scale(1);
        animation-timing-function: linear;
      }
        }`)
    }

    // document.addEventListener('DOMContentLoaded', updateKeyframes(30, 40, 90))
  </script>
</body>

</html>